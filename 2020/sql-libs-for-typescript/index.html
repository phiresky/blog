<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>An overview of SQL libraries for TypeScript - phiresky&#x27;s blog</title><meta name="description" content="Using relational databases in a typed language is a pain unless you have great libraries to support you. There’s a lot of different libraries for TypeScript, but they all have their own advantages and flaws. Since it’s hard to find anything other than TypeORM, this is an overview of the"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="alternate" type="application/rss+xml" title="RSS feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/rss.xml"/><link rel="alternate" type="application/atom+xml" title="Atom feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/atom.xml"/><link rel="alternate" type="application/json" title="JSON feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/feed.json"/><style>
          body {
            font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
          }
      </style><meta name="next-head-count" content="8"/><link rel="preload" href="/blog/_next/static/css/3acfbf97185f61973398.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/3acfbf97185f61973398.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/52d8d008d21e161451c9.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/52d8d008d21e161451c9.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/5010e8538e0af805e524.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/5010e8538e0af805e524.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-63a283d2f74069c6a8dd.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-1e76997b852ac269fbe9.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-d9b220e8b050827068fb.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-00e068cce0587a1a04cb.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-88dabe7ea4fbfcfa845c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/247-98ffd97863a3e7b70e09.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/878-98e4c7d60a75cb0a9a7d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/%5Byear%5D/%5Bpost%5D-8b004dc8d3effe02d586.js" as="script"/></head><body><div id="__next"><div><div><main class="lh-copy"><div class="relative tc bg-dark-gray"><div class="mw7 center white"><div class="pv4"><h1 class="f2 normal lh-title ma0 pa0"><a class="white no-underline" href="/blog/">phiresky&#x27;s blog</a></h1><h4 class="normal o-70 ma0 pt2 pb3 ph1">About my personal projects and other stuff</h4><div><a href="https://phiresky.github.io/blog/" class="dib f6 white no-underline pa1 ma1">Blog</a><a href="https://github.com/phiresky/" class="dib f6 white no-underline pa1 ma1">GitHub</a></div></div></div></div><div class="content center mw7 pa3 pa4-ns"><h1 class="mt0 lh-title mb1">An overview of SQL libraries for TypeScript</h1><small class="db ttu o-40"><time dateTime="2020-06-27T00:00:00.000Z">Jun 27, 2020</time></small><p>Using relational databases in a typed language is a pain unless you have great libraries to support you. There’s a lot of different libraries for TypeScript, but they all have their own advantages and flaws. Since it’s hard to find anything other than TypeORM, this is an overview of the possibilities.</p><p>This is complete overview of SQL libraries for TypeScript. If I’m missing a library, please let me know.</p><h2 id="object-relation-mappers-orms" attrs="[object Object]">Object Relation Mappers (ORMs)</h2><p>In an ORM you declare the schema completely in the host language (TypeScript). The ORM then completely manages synchronization between your objects / classes and the corresponding database tables.</p><p>I’m not a huge fan of ORMs since they always have the same issues: If you have somewhat complex queries, you will get to the limit of the ORM and not be able to represent that query in it without escape hatching. You also lose direct control over how the queries are handled, and thus may get surprising performance issues when the ORM uses suboptimal SQL queries in the background.</p><ul><li><p><a href="https://github.com/typeorm/typeorm" class="auto-linked" attrs="[object Object]">https://github.com/typeorm/typeorm</a></p><p>By far the most popular solution.</p></li><li><p><a href="https://github.com/mikro-orm/mikro-orm" class="auto-linked" attrs="[object Object]">https://github.com/mikro-orm/mikro-orm</a></p><p>Seems pretty nice. There’s a comparison between the two <a href="https://github.com/mikro-orm/mikro-orm/issues/12" attrs="[object Object]">here</a></p></li></ul><h2 id="query-builder-orm-combinations" attrs="[object Object]">Query Builder / ORM combinations</h2><p>These all connect to a dev instance of the database at compile time or in a preprocessing step to figure out the database schema and create the TypeScript types and/or code for it.</p><ul><li><p><a href="https://github.com/prisma/prisma" class="auto-linked" attrs="[object Object]">https://github.com/prisma/prisma</a></p><p>A mix of a query builder and an ORM. Schemas are extracted from a dev instance of the database, which then generates TypeScript code to interact with the database. Very good docs, well thought out.</p></li><li><p><a href="https://github.com/jawj/zapatos" class="auto-linked" attrs="[object Object]">https://github.com/jawj/zapatos</a></p><p>Schemas are extracted from a dev instance of the database. Simple queries (Select, update, insert, each with simple joins) are fully typed with a query-builder like interface. More complex queries are done with raw SQL by manually connecting the schema types with the queries. PostgreSQL only.</p></li><li><p><a href="https://github.com/adelsz/pgtyped" class="auto-linked" attrs="[object Object]">https://github.com/adelsz/pgtyped</a></p><p>Reads raw SQL queries, and figures out the TypeScript input and return types for them by connecting to a dev instance of the database and asking it to interpret the query. Thus it is very flexible while still being statically typed. PostgreSQL only.</p></li></ul><h2 id="fully-typed-query-builders" attrs="[object Object]">Fully Typed Query builders</h2><p>For these you declare your tables in TypeScript, and write your queries in TypeScript in a way that is as similar as possible to raw SQL.</p><p>The library is then able to (ab)use the TypeScript type system to infer the return types of any type of complex query.</p><p>All of these have performance issues and regression issues, since the TS compiler is not optimized for very complex operations, and TS is not backwards compatible, so these libraries often break when a new TS version is released.</p><ul><li><p><a href="https://github.com/phiresky/ts-typed-sql" class="auto-linked" attrs="[object Object]">https://github.com/phiresky/ts-typed-sql</a></p><p>Works well, but unmaintained and missing some SQL features.</p></li><li><p><a href="https://github.com/AnyhowStep/tsql" class="auto-linked" attrs="[object Object]">https://github.com/AnyhowStep/tsql</a></p><p>Probably the most well thought out, but incomplete.</p></li><li><p><a href="https://github.com/Ff00ff/mammoth" class="auto-linked" attrs="[object Object]">https://github.com/Ff00ff/mammoth</a></p><p>The most production ready, but limited to PostgreSQL.</p></li><li><p><a href="https://github.com/travigd/vulcyn" class="auto-linked" attrs="[object Object]">https://github.com/travigd/vulcyn</a></p><p>PostgreSQL only, incomplete.</p></li><li><p><a href="https://github.com/hoeck/typesafe-query-builder" class="auto-linked" attrs="[object Object]">https://github.com/hoeck/typesafe-query-builder</a></p><p>PostgreSQL only, looks good but did not try.</p></li></ul></div><footer class="center w5 f6 tc mt4"><p><a href="https://github.com/phiresky/blog/blob/master/posts/2020/sql-libs-for-typescript.md">View post source on GitHub</a></p></footer><div><script>/* yes, I know... fite me */
  (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='https://www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-39197996-3','auto');ga('send','pageview');
</script></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"filename":"2020/sql-libs-for-typescript.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2020-06-27","hidden":true,"references":[],"title":"An overview of SQL libraries for TypeScript","url2cite-link-output":"sup"},"preview":"Using relational databases in a typed language is a pain unless you have great libraries to support you. There’s a lot of different libraries for TypeScript, but they all have their own advantages and flaws. Since it’s hard to find anything other than TypeORM, this is an overview of the","content_ast":[{"t":"Para","c":[{"t":"Str","c":"Using relational databases in a typed language is a pain unless you have great libraries to support you. There’s a lot of different libraries for TypeScript, but they all have their own advantages and flaws. Since it’s hard to find anything other than TypeORM, this is an overview of the possibilities."}]},{"t":"Para","c":[{"t":"Str","c":"This is complete overview of SQL libraries for TypeScript. If I’m missing a library, please let me know."}]},{"t":"Header","c":[2,["object-relation-mappers-orms",[],[]],[{"t":"Str","c":"Object Relation Mappers (ORMs)"}]]},{"t":"Para","c":[{"t":"Str","c":"In an ORM you declare the schema completely in the host language (TypeScript). The ORM then completely manages synchronization between your objects / classes and the corresponding database tables."}]},{"t":"Para","c":[{"t":"Str","c":"I’m not a huge fan of ORMs since they always have the same issues: If you have somewhat complex queries, you will get to the limit of the ORM and not be able to represent that query in it without escape hatching. You also lose direct control over how the queries are handled, and thus may get surprising performance issues when the ORM uses suboptimal SQL queries in the background."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/typeorm/typeorm"}],["https://github.com/typeorm/typeorm",""]]}]},{"t":"Para","c":[{"t":"Str","c":"By far the most popular solution."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/mikro-orm/mikro-orm"}],["https://github.com/mikro-orm/mikro-orm",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Seems pretty nice. There’s a comparison between the two "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"here"}],["https://github.com/mikro-orm/mikro-orm/issues/12",""]]}]}]]},{"t":"Header","c":[2,["query-builder-orm-combinations",[],[]],[{"t":"Str","c":"Query Builder / ORM combinations"}]]},{"t":"Para","c":[{"t":"Str","c":"These all connect to a dev instance of the database at compile time or in a preprocessing step to figure out the database schema and create the TypeScript types and/or code for it."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/prisma/prisma"}],["https://github.com/prisma/prisma",""]]}]},{"t":"Para","c":[{"t":"Str","c":"A mix of a query builder and an ORM. Schemas are extracted from a dev instance of the database, which then generates TypeScript code to interact with the database. Very good docs, well thought out."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/jawj/zapatos"}],["https://github.com/jawj/zapatos",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Schemas are extracted from a dev instance of the database. Simple queries (Select, update, insert, each with simple joins) are fully typed with a query-builder like interface. More complex queries are done with raw SQL by manually connecting the schema types with the queries. PostgreSQL only."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/adelsz/pgtyped"}],["https://github.com/adelsz/pgtyped",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Reads raw SQL queries, and figures out the TypeScript input and return types for them by connecting to a dev instance of the database and asking it to interpret the query. Thus it is very flexible while still being statically typed. PostgreSQL only."}]}]]},{"t":"Header","c":[2,["fully-typed-query-builders",[],[]],[{"t":"Str","c":"Fully Typed Query builders"}]]},{"t":"Para","c":[{"t":"Str","c":"For these you declare your tables in TypeScript, and write your queries in TypeScript in a way that is as similar as possible to raw SQL."}]},{"t":"Para","c":[{"t":"Str","c":"The library is then able to (ab)use the TypeScript type system to infer the return types of any type of complex query."}]},{"t":"Para","c":[{"t":"Str","c":"All of these have performance issues and regression issues, since the TS compiler is not optimized for very complex operations, and TS is not backwards compatible, so these libraries often break when a new TS version is released."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/phiresky/ts-typed-sql"}],["https://github.com/phiresky/ts-typed-sql",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Works well, but unmaintained and missing some SQL features."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/AnyhowStep/tsql"}],["https://github.com/AnyhowStep/tsql",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Probably the most well thought out, but incomplete."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/Ff00ff/mammoth"}],["https://github.com/Ff00ff/mammoth",""]]}]},{"t":"Para","c":[{"t":"Str","c":"The most production ready, but limited to PostgreSQL."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/travigd/vulcyn"}],["https://github.com/travigd/vulcyn",""]]}]},{"t":"Para","c":[{"t":"Str","c":"PostgreSQL only, incomplete."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/hoeck/typesafe-query-builder"}],["https://github.com/hoeck/typesafe-query-builder",""]]}]},{"t":"Para","c":[{"t":"Str","c":"PostgreSQL only, looks good but did not try."}]}]]}],"default":{"filename":"2020/sql-libs-for-typescript.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2020-06-27","hidden":true,"references":[],"title":"An overview of SQL libraries for TypeScript","url2cite-link-output":"sup"},"preview":"Using relational databases in a typed language is a pain unless you have great libraries to support you. There’s a lot of different libraries for TypeScript, but they all have their own advantages and flaws. Since it’s hard to find anything other than TypeORM, this is an overview of the","content_ast":[{"t":"Para","c":[{"t":"Str","c":"Using relational databases in a typed language is a pain unless you have great libraries to support you. There’s a lot of different libraries for TypeScript, but they all have their own advantages and flaws. Since it’s hard to find anything other than TypeORM, this is an overview of the possibilities."}]},{"t":"Para","c":[{"t":"Str","c":"This is complete overview of SQL libraries for TypeScript. If I’m missing a library, please let me know."}]},{"t":"Header","c":[2,["object-relation-mappers-orms",[],[]],[{"t":"Str","c":"Object Relation Mappers (ORMs)"}]]},{"t":"Para","c":[{"t":"Str","c":"In an ORM you declare the schema completely in the host language (TypeScript). The ORM then completely manages synchronization between your objects / classes and the corresponding database tables."}]},{"t":"Para","c":[{"t":"Str","c":"I’m not a huge fan of ORMs since they always have the same issues: If you have somewhat complex queries, you will get to the limit of the ORM and not be able to represent that query in it without escape hatching. You also lose direct control over how the queries are handled, and thus may get surprising performance issues when the ORM uses suboptimal SQL queries in the background."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/typeorm/typeorm"}],["https://github.com/typeorm/typeorm",""]]}]},{"t":"Para","c":[{"t":"Str","c":"By far the most popular solution."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/mikro-orm/mikro-orm"}],["https://github.com/mikro-orm/mikro-orm",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Seems pretty nice. There’s a comparison between the two "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"here"}],["https://github.com/mikro-orm/mikro-orm/issues/12",""]]}]}]]},{"t":"Header","c":[2,["query-builder-orm-combinations",[],[]],[{"t":"Str","c":"Query Builder / ORM combinations"}]]},{"t":"Para","c":[{"t":"Str","c":"These all connect to a dev instance of the database at compile time or in a preprocessing step to figure out the database schema and create the TypeScript types and/or code for it."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/prisma/prisma"}],["https://github.com/prisma/prisma",""]]}]},{"t":"Para","c":[{"t":"Str","c":"A mix of a query builder and an ORM. Schemas are extracted from a dev instance of the database, which then generates TypeScript code to interact with the database. Very good docs, well thought out."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/jawj/zapatos"}],["https://github.com/jawj/zapatos",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Schemas are extracted from a dev instance of the database. Simple queries (Select, update, insert, each with simple joins) are fully typed with a query-builder like interface. More complex queries are done with raw SQL by manually connecting the schema types with the queries. PostgreSQL only."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/adelsz/pgtyped"}],["https://github.com/adelsz/pgtyped",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Reads raw SQL queries, and figures out the TypeScript input and return types for them by connecting to a dev instance of the database and asking it to interpret the query. Thus it is very flexible while still being statically typed. PostgreSQL only."}]}]]},{"t":"Header","c":[2,["fully-typed-query-builders",[],[]],[{"t":"Str","c":"Fully Typed Query builders"}]]},{"t":"Para","c":[{"t":"Str","c":"For these you declare your tables in TypeScript, and write your queries in TypeScript in a way that is as similar as possible to raw SQL."}]},{"t":"Para","c":[{"t":"Str","c":"The library is then able to (ab)use the TypeScript type system to infer the return types of any type of complex query."}]},{"t":"Para","c":[{"t":"Str","c":"All of these have performance issues and regression issues, since the TS compiler is not optimized for very complex operations, and TS is not backwards compatible, so these libraries often break when a new TS version is released."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/phiresky/ts-typed-sql"}],["https://github.com/phiresky/ts-typed-sql",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Works well, but unmaintained and missing some SQL features."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/AnyhowStep/tsql"}],["https://github.com/AnyhowStep/tsql",""]]}]},{"t":"Para","c":[{"t":"Str","c":"Probably the most well thought out, but incomplete."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/Ff00ff/mammoth"}],["https://github.com/Ff00ff/mammoth",""]]}]},{"t":"Para","c":[{"t":"Str","c":"The most production ready, but limited to PostgreSQL."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/travigd/vulcyn"}],["https://github.com/travigd/vulcyn",""]]}]},{"t":"Para","c":[{"t":"Str","c":"PostgreSQL only, incomplete."}]}],[{"t":"Para","c":[{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://github.com/hoeck/typesafe-query-builder"}],["https://github.com/hoeck/typesafe-query-builder",""]]}]},{"t":"Para","c":[{"t":"Str","c":"PostgreSQL only, looks good but did not try."}]}]]}]}}},"__N_SSG":true},"page":"/[year]/[post]","query":{"year":"2020","post":"sql-libs-for-typescript"},"buildId":"AEBJ__D93-qKOtaOBPPiQ","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-7f99f00b02c1734b8752.js"></script><script src="/blog/_next/static/chunks/webpack-63a283d2f74069c6a8dd.js" async=""></script><script src="/blog/_next/static/chunks/framework-1e76997b852ac269fbe9.js" async=""></script><script src="/blog/_next/static/chunks/commons-d9b220e8b050827068fb.js" async=""></script><script src="/blog/_next/static/chunks/main-00e068cce0587a1a04cb.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-88dabe7ea4fbfcfa845c.js" async=""></script><script src="/blog/_next/static/chunks/247-98ffd97863a3e7b70e09.js" async=""></script><script src="/blog/_next/static/chunks/878-98e4c7d60a75cb0a9a7d.js" async=""></script><script src="/blog/_next/static/chunks/pages/%5Byear%5D/%5Bpost%5D-8b004dc8d3effe02d586.js" async=""></script><script src="/blog/_next/static/AEBJ__D93-qKOtaOBPPiQ/_buildManifest.js" async=""></script><script src="/blog/_next/static/AEBJ__D93-qKOtaOBPPiQ/_ssgManifest.js" async=""></script></body></html>