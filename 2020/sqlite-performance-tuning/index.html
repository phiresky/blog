<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><title data-next-head="">SQLite performance tuning - Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second - phiresky&#x27;s blog</title><meta name="description" content="SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><link rel="alternate" type="application/rss+xml" title="RSS feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/rss.xml" data-next-head=""/><link rel="alternate" type="application/atom+xml" title="Atom feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/atom.xml" data-next-head=""/><link rel="alternate" type="application/json" title="JSON feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/feed.json" data-next-head=""/><style data-next-head="">
          body {
            font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
          }
      </style><link rel="preload" href="/blog/_next/static/css/176ecc217408b6d5.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/176ecc217408b6d5.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/ca399fb16b1ff7a4.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/ca399fb16b1ff7a4.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script defer="" src="/blog/_next/static/chunks/06447f4e.b41930dd9420f16e.js"></script><script defer="" src="/blog/_next/static/chunks/225.64ce7263224d8c5d.js"></script><script src="/blog/_next/static/chunks/webpack-b71e6f5e83c3e25f.js" defer=""></script><script src="/blog/_next/static/chunks/framework-dd2475e04127183a.js" defer=""></script><script src="/blog/_next/static/chunks/main-dded5530337538c6.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-4690c3d9b8989c63.js" defer=""></script><script src="/blog/_next/static/chunks/768-97507726c6ad4e38.js" defer=""></script><script src="/blog/_next/static/chunks/767-8dd3b40e4e29c204.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Byear%5D/%5Bpost%5D-7f75829a52186db8.js" defer=""></script><script src="/blog/_next/static/1duOVj8IRBQqX-jGqm5oV/_buildManifest.js" defer=""></script><script src="/blog/_next/static/1duOVj8IRBQqX-jGqm5oV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div><main class="lh-copy"><div class="relative tc bg-dark-gray"><div class="mw7 center white"><div class="pv4"><h1 class="f2 normal lh-title ma0 pa0"><a class="white no-underline" href="/blog/">phiresky&#x27;s blog</a></h1><h4 class="normal o-70 ma0 pt2 pb3 ph1">Code, Craft, and Creativity</h4><div><a class="dib f6 white no-underline pa1 ma1" href="/blog/">Blog</a><a href="https://github.com/phiresky/" class="dib f6 white no-underline pa1 ma1">GitHub</a></div></div></div></div><div class="content center mw7 pa3 pa4-ns"><h1 class="mt0 lh-title mb1">SQLite performance tuning</h1><p class="mt0">Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second</p><small class="db ttu o-40"><time dateTime="2020-06-26T00:00:00.000Z">Jun 26, 2020</time> • <a href="https://github.com/phiresky/blog/commits/master/posts/2020/sqlite-performance-tuning.md">Last Update <time dateTime="2020-06-26T00:00:00.000Z">Jul 31, 2022</time></a></small><p>SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time.</p><p>SQLite is often seen as a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations.</p><h2 id="run-these-every-time-you-connect-to-the-db">Run these every time you connect to the DB</h2><p>Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database.</p><ul><li><p>Journal Mode</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma journal_mode </span><span class="token token" style="color:#67cdcc">=</span><span> WAL</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers even during an open write transaction, and can significantly improve performance.</p></li><li><p>Synchronous Commit</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma synchronous </span><span class="token token" style="color:#67cdcc">=</span><span> normal</span><span class="token token" style="color:#ccc">;</span></code></pre><p>or even <code class="not-highlighted">synchronous=off</code>. The default is <code class="not-highlighted">full</code>, which means every single update has to wait for <a href="https://en.wikipedia.org/wiki/Sync_(Unix)">FSYNC</a>. Normal is still completely corruption safe in WAL mode, and means only WAL checkpoints have to wait for FSYNC. Off can cause db corruption, though I’ve never had problems. See here: <a href="https://www.sqlite.org/pragma.html#pragma_synchronous" class="auto-linked">https://www.sqlite.org/pragma.html#pragma_synchronous</a></p></li><li><p>Temporary files location</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma temp_store </span><span class="token token" style="color:#67cdcc">=</span><span> memory</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Stores temporary indices / tables in memory. sqlite automatically <a href="https://www.sqlite.org/tempfiles.html#transient_indices">creates temporary indices</a> for some queries. Not sure how much this one helps. If your SQLite is creating temporary indices (check with <code class="not-highlighted">EXPLAIN QUERY PLAN</code>) you should probably create those indexes yourself in any case.</p></li><li><p>Enable memory mapping</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma mmap_size </span><span class="token token" style="color:#67cdcc">=</span><span> </span><span class="token token" style="color:#f08d49">30000000000</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Uses memory mapping instead of read/write calls when the database is &lt; mmap_size in bytes. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use the amount of physical memory, it will just reserve virtual memory. The OS will then decide which pages are evicted and which stay in memory based on its usual <span class="quoted">&quot;<!-- -->disk caching<!-- -->&quot;</span> logic. Should be much faster, at least on Linux and if you have a fair amount of memory for your SQLite process. If your database is larger than the given mmap_size, the first part of the database will still be memory mapped, the rest will be handled with read() / write() syscalls.</p><p>If you are on a 32-bit system you can probably only set this to less than <span data-testid="react-katex"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span></span> bytes since the size of the virtual memory space is limited.</p><p>Memory mapping can also have implications when there are I/O errors, see <a href="https://sqlite.org/mmap.html">the official documentation</a>.</p></li><li><p>Increase the page size</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma page_size </span><span class="token token" style="color:#67cdcc">=</span><span> </span><span class="token token" style="color:#f08d49">32768</span><span class="token token" style="color:#ccc">;</span></code></pre><p>This improved performance and db size a lot for me in one project, but it’s probably only useful if you are storing somewhat large blobs in your database and might not be good for other projects where rows are small. For writing queries SQLite will always only replace whole pages, so this increases the overhead of write queries.</p></li></ul><h3 id="summary">Summary</h3><p>If you’re too lazy to read all the above, just run this on every database connect:</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma journal_mode </span><span class="token token" style="color:#67cdcc">=</span><span> WAL</span><span class="token token" style="color:#ccc">;</span><span>
</span><span>pragma synchronous </span><span class="token token" style="color:#67cdcc">=</span><span> normal</span><span class="token token" style="color:#ccc">;</span><span>
</span><span>pragma temp_store </span><span class="token token" style="color:#67cdcc">=</span><span> memory</span><span class="token token" style="color:#ccc">;</span><span>
</span><span>pragma mmap_size </span><span class="token token" style="color:#67cdcc">=</span><span> </span><span class="token token" style="color:#f08d49">30000000000</span><span class="token token" style="color:#ccc">;</span></code></pre><h2 id="more-things-that-must-be-run-manually">More things that must be run manually</h2><ul><li><p>Reorganize the database</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma vacuum</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Run once to completely rewrite the db. Very expensive if your database is 100MB+.</p></li><li><p>Re-analyze the database</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma </span><span class="token token" style="color:#cc99cd">optimize</span><span class="token token" style="color:#ccc">;</span></code></pre><blockquote><p>To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run <span class="quoted">&quot;<!-- -->PRAGMA optimize<!-- -->&quot;</span> (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run <span class="quoted">&quot;<!-- -->PRAGMA optimize<!-- -->&quot;</span> every few hours. <span class="source"><a href="https://www.sqlite.org/pragma.html#pragma_optimize" class="uri">https://www.sqlite.org/pragma.html#pragma_optimize</a></span></p></blockquote></li><li><p>Vacuum the database</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="white-space:pre;color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma auto_vacuum </span><span class="token token" style="color:#67cdcc">=</span><span> incremental</span><span class="token token" style="color:#ccc">;</span><span> </span><span class="token token" style="color:#999">-- once on first DB create</span><span>
</span><span>pragma incremental_vacuum</span><span class="token token" style="color:#ccc">;</span><span> </span><span class="token token" style="color:#999">-- regularily</span></code></pre><p>Probably not useful unless you expect your DB to shrink significantly regularily.</p><blockquote><p>The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse. <span class="source"><a href="https://www.sqlite.org/pragma.html#pragma_incremental_vacuum" class="uri">https://www.sqlite.org/pragma.html#pragma_incremental_vacuum</a></span></p></blockquote></li></ul><h2 id="regarding-wal-mode">Regarding WAL mode</h2><p>WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to <a href="https://www.sqlite.org/wal.html#ckpt">doing wal_autocheckpoint</a>. There’s a few ways to mitigate this:</p><ol start="1" type="1"><li>Reduce <a href="https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint">wal_autocheckpoint interval</a>. No guarantees since all autocheckpoints are passive.</li><li>Run <code class="not-highlighted">pragma wal_checkpoint(full)</code> or <code class="not-highlighted">pragma wal_checkpoint(truncate)</code> sometimes. With <code class="not-highlighted">full</code>, the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run <code class="not-highlighted">truncate</code> it will block other processes and reset the WAL file to zero bytes. Note that you <em>can</em> run these from a separate process, it will just block other write queries for a bit.</li></ol></div><footer class="center w5 f6 tc mt4"><p><a href="https://github.com/phiresky/blog/blob/master/posts/2020/sqlite-performance-tuning.md">View post source on GitHub</a></p></footer><div></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"filename":"2020/sqlite-performance-tuning.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2020-06-26","hidden":false,"references":[],"subtitle":"Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second","title":"SQLite performance tuning","updated":"2022-07-31","url2cite-link-output":"sup"},"preview":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only","content_ast":[{"t":"Para","c":[{"t":"Str","c":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time."}]},{"t":"Para","c":[{"t":"Str","c":"SQLite is often seen as a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations."}]},{"t":"Header","c":[2,["run-these-every-time-you-connect-to-the-db",[],[]],[{"t":"Str","c":"Run these every time you connect to the DB"}]]},{"t":"Para","c":[{"t":"Str","c":"Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Journal Mode"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;"]},{"t":"Para","c":[{"t":"Str","c":"Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers even during an open write transaction, and can significantly improve performance."}]}],[{"t":"Para","c":[{"t":"Str","c":"Synchronous Commit"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma synchronous = normal;"]},{"t":"Para","c":[{"t":"Str","c":"or even "},{"t":"Code","c":[["",[],[]],"synchronous=off"]},{"t":"Str","c":". The default is "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", which means every single update has to wait for "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"FSYNC"}],["https://en.wikipedia.org/wiki/Sync_(Unix)",""]]},{"t":"Str","c":". Normal is still completely corruption safe in WAL mode, and means only WAL checkpoints have to wait for FSYNC. Off can cause db corruption, though I’ve never had problems. See here: "},{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_synchronous"}],["https://www.sqlite.org/pragma.html#pragma_synchronous",""]]}]}],[{"t":"Para","c":[{"t":"Str","c":"Temporary files location"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma temp_store = memory;"]},{"t":"Para","c":[{"t":"Str","c":"Stores temporary indices / tables in memory. sqlite automatically "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"creates temporary indices"}],["https://www.sqlite.org/tempfiles.html#transient_indices",""]]},{"t":"Str","c":" for some queries. Not sure how much this one helps. If your SQLite is creating temporary indices (check with "},{"t":"Code","c":[["",[],[]],"EXPLAIN QUERY PLAN"]},{"t":"Str","c":") you should probably create those indexes yourself in any case."}]}],[{"t":"Para","c":[{"t":"Str","c":"Enable memory mapping"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma mmap_size = 30000000000;"]},{"t":"Para","c":[{"t":"Str","c":"Uses memory mapping instead of read/write calls when the database is \u003c mmap_size in bytes. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use the amount of physical memory, it will just reserve virtual memory. The OS will then decide which pages are evicted and which stay in memory based on its usual "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"disk caching"}]]},{"t":"Str","c":" logic. Should be much faster, at least on Linux and if you have a fair amount of memory for your SQLite process. If your database is larger than the given mmap_size, the first part of the database will still be memory mapped, the rest will be handled with read() / write() syscalls."}]},{"t":"Para","c":[{"t":"Str","c":"If you are on a 32-bit system you can probably only set this to less than "},{"t":"Math","c":[{"t":"InlineMath"},"2^{32}"]},{"t":"Str","c":" bytes since the size of the virtual memory space is limited."}]},{"t":"Para","c":[{"t":"Str","c":"Memory mapping can also have implications when there are I/O errors, see "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"the official documentation"}],["https://sqlite.org/mmap.html",""]]},{"t":"Str","c":"."}]}],[{"t":"Para","c":[{"t":"Str","c":"Increase the page size"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma page_size = 32768;"]},{"t":"Para","c":[{"t":"Str","c":"This improved performance and db size a lot for me in one project, but it’s probably only useful if you are storing somewhat large blobs in your database and might not be good for other projects where rows are small. For writing queries SQLite will always only replace whole pages, so this increases the overhead of write queries."}]}]]},{"t":"Header","c":[3,["summary",[],[]],[{"t":"Str","c":"Summary"}]]},{"t":"Para","c":[{"t":"Str","c":"If you’re too lazy to read all the above, just run this on every database connect:"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;\npragma synchronous = normal;\npragma temp_store = memory;\npragma mmap_size = 30000000000;"]},{"t":"Header","c":[2,["more-things-that-must-be-run-manually",[],[]],[{"t":"Str","c":"More things that must be run manually"}]]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Reorganize the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma vacuum;"]},{"t":"Para","c":[{"t":"Str","c":"Run once to completely rewrite the db. Very expensive if your database is 100MB+."}]}],[{"t":"Para","c":[{"t":"Str","c":"Re-analyze the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma optimize;"]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" every few hours. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_optimize"}],["https://www.sqlite.org/pragma.html#pragma_optimize",""]]}]]}]}]}],[{"t":"Para","c":[{"t":"Str","c":"Vacuum the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma auto_vacuum = incremental; -- once on first DB create\npragma incremental_vacuum; -- regularily"]},{"t":"Para","c":[{"t":"Str","c":"Probably not useful unless you expect your DB to shrink significantly regularily."}]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_incremental_vacuum"}],["https://www.sqlite.org/pragma.html#pragma_incremental_vacuum",""]]}]]}]}]}]]},{"t":"Header","c":[2,["regarding-wal-mode",[],[]],[{"t":"Str","c":"Regarding WAL mode"}]]},{"t":"Para","c":[{"t":"Str","c":"WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"doing wal_autocheckpoint"}],["https://www.sqlite.org/wal.html#ckpt",""]]},{"t":"Str","c":". There’s a few ways to mitigate this:"}]},{"t":"OrderedList","c":[[1,{"t":"Decimal"},{"t":"Period"}],[[{"t":"Plain","c":[{"t":"Str","c":"Reduce "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"wal_autocheckpoint interval"}],["https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint",""]]},{"t":"Str","c":". No guarantees since all autocheckpoints are passive."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Run "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(full)"]},{"t":"Str","c":" or "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(truncate)"]},{"t":"Str","c":" sometimes. With "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run "},{"t":"Code","c":[["",[],[]],"truncate"]},{"t":"Str","c":" it will block other processes and reset the WAL file to zero bytes. Note that you "},{"t":"Emph","c":[{"t":"Str","c":"can"}]},{"t":"Str","c":" run these from a separate process, it will just block other write queries for a bit."}]}]]]}],"default":{"filename":"2020/sqlite-performance-tuning.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2020-06-26","hidden":false,"references":[],"subtitle":"Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second","title":"SQLite performance tuning","updated":"2022-07-31","url2cite-link-output":"sup"},"preview":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only","content_ast":[{"t":"Para","c":[{"t":"Str","c":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time."}]},{"t":"Para","c":[{"t":"Str","c":"SQLite is often seen as a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations."}]},{"t":"Header","c":[2,["run-these-every-time-you-connect-to-the-db",[],[]],[{"t":"Str","c":"Run these every time you connect to the DB"}]]},{"t":"Para","c":[{"t":"Str","c":"Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Journal Mode"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;"]},{"t":"Para","c":[{"t":"Str","c":"Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers even during an open write transaction, and can significantly improve performance."}]}],[{"t":"Para","c":[{"t":"Str","c":"Synchronous Commit"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma synchronous = normal;"]},{"t":"Para","c":[{"t":"Str","c":"or even "},{"t":"Code","c":[["",[],[]],"synchronous=off"]},{"t":"Str","c":". The default is "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", which means every single update has to wait for "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"FSYNC"}],["https://en.wikipedia.org/wiki/Sync_(Unix)",""]]},{"t":"Str","c":". Normal is still completely corruption safe in WAL mode, and means only WAL checkpoints have to wait for FSYNC. Off can cause db corruption, though I’ve never had problems. See here: "},{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_synchronous"}],["https://www.sqlite.org/pragma.html#pragma_synchronous",""]]}]}],[{"t":"Para","c":[{"t":"Str","c":"Temporary files location"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma temp_store = memory;"]},{"t":"Para","c":[{"t":"Str","c":"Stores temporary indices / tables in memory. sqlite automatically "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"creates temporary indices"}],["https://www.sqlite.org/tempfiles.html#transient_indices",""]]},{"t":"Str","c":" for some queries. Not sure how much this one helps. If your SQLite is creating temporary indices (check with "},{"t":"Code","c":[["",[],[]],"EXPLAIN QUERY PLAN"]},{"t":"Str","c":") you should probably create those indexes yourself in any case."}]}],[{"t":"Para","c":[{"t":"Str","c":"Enable memory mapping"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma mmap_size = 30000000000;"]},{"t":"Para","c":[{"t":"Str","c":"Uses memory mapping instead of read/write calls when the database is \u003c mmap_size in bytes. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use the amount of physical memory, it will just reserve virtual memory. The OS will then decide which pages are evicted and which stay in memory based on its usual "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"disk caching"}]]},{"t":"Str","c":" logic. Should be much faster, at least on Linux and if you have a fair amount of memory for your SQLite process. If your database is larger than the given mmap_size, the first part of the database will still be memory mapped, the rest will be handled with read() / write() syscalls."}]},{"t":"Para","c":[{"t":"Str","c":"If you are on a 32-bit system you can probably only set this to less than "},{"t":"Math","c":[{"t":"InlineMath"},"2^{32}"]},{"t":"Str","c":" bytes since the size of the virtual memory space is limited."}]},{"t":"Para","c":[{"t":"Str","c":"Memory mapping can also have implications when there are I/O errors, see "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"the official documentation"}],["https://sqlite.org/mmap.html",""]]},{"t":"Str","c":"."}]}],[{"t":"Para","c":[{"t":"Str","c":"Increase the page size"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma page_size = 32768;"]},{"t":"Para","c":[{"t":"Str","c":"This improved performance and db size a lot for me in one project, but it’s probably only useful if you are storing somewhat large blobs in your database and might not be good for other projects where rows are small. For writing queries SQLite will always only replace whole pages, so this increases the overhead of write queries."}]}]]},{"t":"Header","c":[3,["summary",[],[]],[{"t":"Str","c":"Summary"}]]},{"t":"Para","c":[{"t":"Str","c":"If you’re too lazy to read all the above, just run this on every database connect:"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;\npragma synchronous = normal;\npragma temp_store = memory;\npragma mmap_size = 30000000000;"]},{"t":"Header","c":[2,["more-things-that-must-be-run-manually",[],[]],[{"t":"Str","c":"More things that must be run manually"}]]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Reorganize the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma vacuum;"]},{"t":"Para","c":[{"t":"Str","c":"Run once to completely rewrite the db. Very expensive if your database is 100MB+."}]}],[{"t":"Para","c":[{"t":"Str","c":"Re-analyze the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma optimize;"]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" every few hours. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_optimize"}],["https://www.sqlite.org/pragma.html#pragma_optimize",""]]}]]}]}]}],[{"t":"Para","c":[{"t":"Str","c":"Vacuum the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma auto_vacuum = incremental; -- once on first DB create\npragma incremental_vacuum; -- regularily"]},{"t":"Para","c":[{"t":"Str","c":"Probably not useful unless you expect your DB to shrink significantly regularily."}]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_incremental_vacuum"}],["https://www.sqlite.org/pragma.html#pragma_incremental_vacuum",""]]}]]}]}]}]]},{"t":"Header","c":[2,["regarding-wal-mode",[],[]],[{"t":"Str","c":"Regarding WAL mode"}]]},{"t":"Para","c":[{"t":"Str","c":"WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"doing wal_autocheckpoint"}],["https://www.sqlite.org/wal.html#ckpt",""]]},{"t":"Str","c":". There’s a few ways to mitigate this:"}]},{"t":"OrderedList","c":[[1,{"t":"Decimal"},{"t":"Period"}],[[{"t":"Plain","c":[{"t":"Str","c":"Reduce "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"wal_autocheckpoint interval"}],["https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint",""]]},{"t":"Str","c":". No guarantees since all autocheckpoints are passive."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Run "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(full)"]},{"t":"Str","c":" or "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(truncate)"]},{"t":"Str","c":" sometimes. With "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run "},{"t":"Code","c":[["",[],[]],"truncate"]},{"t":"Str","c":" it will block other processes and reset the WAL file to zero bytes. Note that you "},{"t":"Emph","c":[{"t":"Str","c":"can"}]},{"t":"Str","c":" run these from a separate process, it will just block other write queries for a bit."}]}]]]}]}}},"__N_SSG":true},"page":"/[year]/[post]","query":{"year":"2020","post":"sqlite-performance-tuning"},"buildId":"1duOVj8IRBQqX-jGqm5oV","assetPrefix":"/blog","isFallback":false,"dynamicIds":[8225],"gsp":true,"scriptLoader":[]}</script></body></html>